services:
  lightrag:
    build:
      context: .
      dockerfile_inline: |
        # Build stage
        FROM python:3.12-slim-bookworm AS builder

        WORKDIR /app

        # Install Rust and required build dependencies
        RUN apt-get update && apt-get install -y \
            curl \
            build-essential \
            pkg-config \
            git \
            && rm -rf /var/lib/apt/lists/* \
            && curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \
            && . $HOME/.cargo/env

        # Clone LightRAG repository 
        RUN git clone https://github.com/HKUDS/LightRAG.git .

        # Install dependencies
        ENV PATH="/root/.cargo/bin:${PATH}"
        RUN pip install --user --no-cache-dir -r requirements.txt \
            && pip install --user --no-cache-dir -r lightrag/api/requirements.txt

        # Final stage
        FROM python:3.12-slim-bookworm

        WORKDIR /app

        RUN apt-get update && apt-get install -y \
            curl

        # Copy only necessary files from builder
        COPY --from=builder /root/.local /root/.local
        COPY --from=builder /app/lightrag ./lightrag
        COPY --from=builder /app/setup.py .

        RUN pip install .

        # Make sure scripts in .local are usable
        ENV PATH=/root/.local/bin:$PATH

        # Create necessary directories
        RUN mkdir -p /app/data /app/data/working_dir /app/config

        # Expose the default port
        EXPOSE 9621
    restart: unless-stopped
    depends_on:
      neo4j:
        condition: service_healthy
    volumes:
      - ./data:/app/data
      - ./config:/app/config
    environment:
      - SERVICE_FQDN_LIGHTRAG_9621
      - WEBUI_TITLE=LightRAG
      - WEBUI_DESCRIPTION=Simple and Fast Graph Based RAG System
      # Settings for document indexing
      - ENABLE_LLM_CACHE_FOR_EXTRACT=${ENABLE_LLM_CACHE_FOR_EXTRACT:-true}
      - MAX_PARALLEL_INSERT=${MAX_PARALLEL_INSERT:-2}
      - SUMMARY_LANGUAGE=${SUMMARY_LANGUAGE:-English}
      - CHUNK_SIZE=${CHUNK_SIZE:-1200}
      - CHUNK_OVERLAP_SIZE=${CHUNK_OVERLAP_SIZE:-100}
      # LLM Configuration
      - TIMEOUT=${TIMEOUT:-200}
      - TEMPERATURE=${TEMPERATURE:-0.0}
      - MAX_ASYNC=${MAX_ASYNC:-4}
      - MAX_TOKENS=${MAX_TOKENS:-32768}
      - LLM_BINDING=${LLM_BINDING:-openai}
      - LLM_MODEL=${LLM_MODEL:-gpt-4.1-mini}
      - LLM_BINDING_HOST=${LLM_BINDING_HOST:-https://api.openai.com/v1}
      - LLM_BINDING_API_KEY=${LLM_BINDING_API_KEY}
      # Embedding Configuration - Using OpenAI for embeddings
      - EMBEDDING_MODEL=${EMBEDDING_MODEL:-text-embedding-3-large}
      - EMBEDDING_DIM=${EMBEDDING_DIM:-1536}
      - EMBEDDING_BINDING=${EMBEDDING_BINDING:-openai}
      - EMBEDDING_BINDING_HOST=${EMBEDDING_BINDING_HOST:-https://api.openai.com/v1}
      - EMBEDDING_BINDING_API_KEY=${EMBEDDING_BINDING_API_KEY}
      # Storage Configuration
      - LIGHTRAG_KV_STORAGE=PGKVStorage
      - LIGHTRAG_VECTOR_STORAGE=PGVectorStorage
      - LIGHTRAG_GRAPH_STORAGE=Neo4JStorage
      - LIGHTRAG_DOC_STATUS_STORAGE=PGDocStatusStorage
      # PostgreSQL Configuration
      - POSTGRES_HOST=${POSTGRES_HOST:-postgres}
      - POSTGRES_PORT=${POSTGRES_PORT:-5432}
      - POSTGRES_USER=${POSTGRES_USER:-postgres}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-postgres}
      - POSTGRES_DATABASE=${POSTGRES_DATABASE:-postgres}
      # Neo4j Configuration
      - NEO4J_URI=${NEO4J_URI:-bolt://neo4j:7687}
      - NEO4J_USERNAME=neo4j
      - NEO4J_PASSWORD=${SERVICE_PASSWORD_NEO4J}
      # Authentication
      - LIGHTRAG_API_KEY=${SERVICE_BASE64_LIGHTRAG}
      - AUTH_ACCOUNTS=admin:${SERVICE_PASSWORD_LIGHTRAG}
      - TOKEN_SECRET=${SERVICE_REALBASE64_TOKEN}
      - TOKEN_EXPIRE_HOURS=${TOKEN_EXPIRE_HOURS:-48}
      - WHITELIST_PATHS=/health,/api/*
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9621/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    entrypoint: ["python", "-m", "lightrag.api.lightrag_server"]

  neo4j:
    image: graphstack/dozerdb:5.26.3.0
    restart: unless-stopped
    environment:
      - NEO4J_AUTH=neo4j/${SERVICE_PASSWORD_NEO4J}
      - NEO4J_PLUGINS='["apoc"]'
      - NEO4J_apoc_export_file_enabled=true
      - NEO4J_apoc_import_file_enabled=true
      - NEO4J_dbms_security_procedures_unrestricted='*'
    volumes:
      - neo4j-data:/data
      - neo4j-logs:/logs
      - neo4j-plugins:/plugins
      - neo4j-import:/var/lib/neo4j/import
    healthcheck:
      test: wget http://localhost:7474 || exit 1
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  mcp:
    build:
      context: .
      dockerfile_inline: |
        # Build stage
        FROM node:22-slim AS builder
        
        WORKDIR /app
        
        # Install dependencies in a single layer to reduce image size
        RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
        
        # Install dependencies including express for HTTP server
        COPY ./mcp/package.json .

        # Install dependencies
        RUN npm install
        
        # Create TypeScript config and source files
        COPY ./mcp/tsconfig.json .
        COPY ./mcp/src ./src
        
        # Build TypeScript code
        RUN npm run build
        
        # Runtime stage
        FROM node:22-slim
        
        WORKDIR /app
        
        # Install only production dependencies
        COPY ./mcp/package.json .
        RUN npm install --production && \
            apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
        
        # Copy built files from builder stage
        COPY --from=builder /app/build ./build
        
        # Expose HTTP port
        EXPOSE 3000
    volumes:
      - type: bind
        source: ./mcp/package.json
        target: /app/package.json
        content: |
          {
            "name": "lightrag-mcp-server",
            "version": "0.1.0",
            "type": "module",
            "scripts": {
              "build": "tsc && chmod +x build/index.js",
              "start": "node build/index.js"
            },
            "dependencies": {
              "@modelcontextprotocol/sdk": "^1.11.0",
              "axios": "^1.6.0",
              "express": "^4.18.2",
              "form-data": "^4.0.0",
              "zod": "^3.22.4"
            },
            "devDependencies": {
              "@types/express": "^4.17.17",
              "@types/node": "^20.4.5",
              "typescript": "^5.0.0"
            }
          }
      - type: bind
        source: ./mcp/tsconfig.json
        target: /app/tsconfig.json
        content: |
          {
            "compilerOptions": {
              "target": "ES2020",
              "module": "NodeNext",
              "moduleResolution": "NodeNext",
              "esModuleInterop": true,
              "outDir": "build",
              "strict": true,
              "skipLibCheck": true,
              "resolveJsonModule": true
            },
            "include": ["src/**/*"]
          }
      - type: bind
        source: ./mcp/src/index.ts
        target: /app/src/index.ts
        content: |
          #!/usr/bin/env node
          import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
          import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
          import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
          import { Request, Response } from "express";
          import express from "express";
          import axios from "axios";
          import FormData from "form-data";
          import { z } from "zod";

          const API_URL = process.env.LIGHTRAG_API_URL || "http://lightrag:9621";
          const LIGHTRAG_API_KEY = process.env.LIGHTRAG_API_KEY;
          const MCP_API_KEY = process.env.MCP_API_KEY;
          const PORT = process.env.PORT || 3000;

          if (!LIGHTRAG_API_KEY) {
            throw new Error("LIGHTRAG_API_KEY environment variable is required");
          }

          if (!MCP_API_KEY) {
            throw new Error("MCP_API_KEY environment variable is required");
          }

          // Create a single reusable function to get a configured axios instance
          function getLightRAGClient(isFormData = false) {
            const headers: Record<string, string> = {
              "X-API-Key": LIGHTRAG_API_KEY as string,
            };
            
            // Add Content-Type header only for non-form data requests
            if (!isFormData) {
              headers["Content-Type"] = "application/json";
            }
            
            return axios.create({
              baseURL: API_URL,
              headers,
            });
          }

          // Helper function to format response data into MCP content format
          function formatResponse(data: any, isError: boolean = false) {
            return {
              content: [
                {
                  type: "text",
                  text: JSON.stringify(data, null, 2)
                }
              ],
              isError
            };
          }

          // Store transports for each session type
          const transports = {
            streamable: {} as Record<string, StreamableHTTPServerTransport>,
            sse: {} as Record<string, SSEServerTransport>
          };

          // Function to create a new server instance
          function getServer() {
            const server = new McpServer({
              name: "lightrag-mcp-server",
              version: "0.1.0",
            });
            
            // Set up tool handlers
            server.tool(
              "query_lightrag",
              {
                query: z.string().describe("The query to send to LightRAG"),
                mode: z.enum(["local", "global", "hybrid", "mix", "naive"])
                  .describe("Retrieval mode (local, global, hybrid, mix, naive)")
                  .default("hybrid")
                  .optional()
              },
              async (args) => {
                try {
                  const { query, mode } = args;
                  const client = getLightRAGClient();
                  
                  const response = await client.post("/query", {
                    query,
                    mode: mode || "hybrid",
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error querying LightRAG: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            server.tool(
              "list_documents",
              {},
              async (args) => {
                try {
                  const client = getLightRAGClient();
                  
                  const response = await client.get("/documents");
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error listing documents: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            server.tool(
              "upload_document",
              {
                content: z.string().describe("Document content"),
                filename: z.string().describe("Document filename")
              },
              async (args) => {
                try {
                  const { content, filename } = args;
                  const client = getLightRAGClient(true);
                  
                  const formData = new FormData();
                  
                  // Create a Buffer from the content string
                  const buffer = Buffer.from(content);
                  formData.append("file", buffer, filename);
                  
                  const response = await client.post("/documents/upload", formData, {
                    headers: {
                      ...formData.getHeaders(),
                    },
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error uploading document: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );

            // Add scan_documents tool
            server.tool(
              "scan_documents",
              {},
              async (args) => {
                try {
                  const client = getLightRAGClient();
                  
                  const response = await client.post("/documents/scan");
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error scanning documents: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add insert_text tool
            server.tool(
              "insert_text",
              {
                text: z.string().describe("The text to insert")
              },
              async (args) => {
                try {
                  const { text } = args;
                  const client = getLightRAGClient();
                  
                  const response = await client.post("/documents/text", {
                    text
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error inserting text: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add insert_texts tool
            server.tool(
              "insert_texts",
              {
                texts: z.array(z.string()).describe("List of texts to insert")
              },
              async (args) => {
                try {
                  const { texts } = args;
                  const client = getLightRAGClient();
                  
                  const response = await client.post("/documents/texts", {
                    texts
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error inserting texts: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add insert_file tool
            server.tool(
              "insert_file",
              {
                content: z.string().describe("File content"),
                filename: z.string().describe("File name")
              },
              async (args) => {
                try {
                  const { content, filename } = args;
                  const client = getLightRAGClient(true);
                  
                  const formData = new FormData();
                  
                  // Create a Buffer from the content string
                  const buffer = Buffer.from(content);
                  formData.append("file", buffer, filename);
                  
                  const response = await client.post("/documents/file", formData, {
                    headers: {
                      ...formData.getHeaders(),
                    },
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error inserting file: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add insert_file_batch tool
            server.tool(
              "insert_file_batch",
              {
                files: z.array(
                  z.object({
                    content: z.string().describe("File content"),
                    filename: z.string().describe("File name")
                  })
                ).describe("List of files to process")
              },
              async (args) => {
                try {
                  const { files } = args;
                  const client = getLightRAGClient(true);
                  
                  const formData = new FormData();
                  
                  // Add each file to the form data
                  files.forEach((file, index) => {
                    const buffer = Buffer.from(file.content);
                    formData.append("files", buffer, file.filename);
                  });
                  
                  const response = await client.post("/documents/file_batch", formData, {
                    headers: {
                      ...formData.getHeaders(),
                    },
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error inserting file batch: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add get_pipeline_status tool
            server.tool(
              "get_pipeline_status",
              {},
              async (args) => {
                try {
                  const client = getLightRAGClient();
                  
                  const response = await client.get("/documents/pipeline_status");
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error getting pipeline status: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add clear_cache tool
            server.tool(
              "clear_cache",
              {
                modes: z.array(
                  z.enum(["default", "naive", "local", "global", "hybrid", "mix"])
                ).describe("Modes of cache to clear").optional()
              },
              async (args) => {
                try {
                  const { modes } = args;
                  const client = getLightRAGClient();
                  
                  const response = await client.post("/documents/clear_cache", {
                    modes
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error clearing cache: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add clear_documents tool
            server.tool(
              "clear_documents",
              {},
              async (args) => {
                try {
                  const client = getLightRAGClient();
                  
                  const response = await client.delete("/documents");
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error clearing documents: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add query_stream tool
            server.tool(
              "query_stream",
              {
                query: z.string().describe("The query to send to LightRAG"),
                mode: z.enum(["local", "global", "hybrid", "mix", "naive", "bypass"])
                  .describe("Retrieval mode")
                  .default("hybrid")
                  .optional()
              },
              async (args) => {
                try {
                  const { query, mode } = args;
                  const client = getLightRAGClient();
                  
                  // Note: This is a simplified implementation as streaming requires special handling
                  const response = await client.post("/query/stream", {
                    query,
                    mode: mode || "hybrid",
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error streaming query: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add get_graph_labels tool
            server.tool(
              "get_graph_labels",
              {},
              async (args) => {
                try {
                  const client = getLightRAGClient();
                  
                  const response = await client.get("/graph/label/list");
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error getting graph labels: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add get_knowledge_graph tool
            server.tool(
              "get_knowledge_graph",
              {
                label: z.string().describe("Label to get knowledge graph for"),
                max_depth: z.number().min(1).describe("Maximum depth of graph").default(3).optional(),
                max_nodes: z.number().min(1).describe("Maximum nodes to return").default(1000).optional()
              },
              async (args) => {
                try {
                  const { label, max_depth, max_nodes } = args;
                  const client = getLightRAGClient();
                  
                  const response = await client.get("/graphs", {
                    params: {
                      label,
                      max_depth: max_depth || 3,
                      max_nodes: max_nodes || 1000
                    }
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error getting knowledge graph: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add check_entity_exists tool
            server.tool(
              "check_entity_exists",
              {
                name: z.string().describe("Entity name to check")
              },
              async (args) => {
                try {
                  const { name } = args;
                  const client = getLightRAGClient();
                  
                  const response = await client.get("/graph/entity/exists", {
                    params: { name }
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error checking entity existence: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add update_entity tool
            server.tool(
              "update_entity",
              {
                entity_name: z.string().describe("Entity name"),
                updated_data: z.record(z.any()).describe("Updated data"),
                allow_rename: z.boolean().describe("Allow rename").default(false).optional()
              },
              async (args) => {
                try {
                  const { entity_name, updated_data, allow_rename } = args;
                  const client = getLightRAGClient();
                  
                  const response = await client.post("/graph/entity/edit", {
                    entity_name,
                    updated_data,
                    allow_rename: allow_rename || false
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error updating entity: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            // Add update_relation tool
            server.tool(
              "update_relation",
              {
                source_id: z.string().describe("Source ID"),
                target_id: z.string().describe("Target ID"),
                updated_data: z.record(z.any()).describe("Updated data")
              },
              async (args) => {
                try {
                  const { source_id, target_id, updated_data } = args;
                  const client = getLightRAGClient();
                  
                  const response = await client.post("/graph/relation/edit", {
                    source_id,
                    target_id,
                    updated_data
                  });
                  
                  return {
                    content: [
                      {
                        type: "text",
                        text: JSON.stringify(response.data, null, 2)
                      }
                    ]
                  };
                } catch (error: any) {
                  return {
                    content: [
                      {
                        type: "text",
                        text: `Error updating relation: ${error.message}`
                      }
                    ],
                    isError: true
                  };
                }
              }
            );
            
            return server;
          }

          // Create Express app
          const app = express();
          app.use(express.json());

          // Add health check endpoint
          app.get('/health', (req: Request, res: Response) => {
            res.status(200).send('OK');
          });

          // Add authentication middleware
          function authenticate(req: Request, res: Response, next: Function) {
            const authHeader = req.headers['authorization'];
            if (!authHeader || authHeader !== `Bearer ${MCP_API_KEY}`) {
              return res.status(401).json({
                jsonrpc: '2.0',
                error: {
                  code: -32001,
                  message: 'Unauthorized',
                },
                id: null,
              });
            }
            next();
          }

          // Simple logging function
          function log(message: string, level: 'info' | 'warn' | 'error' = 'info') {
            const timestamp = new Date().toISOString();
            const prefix = level === 'error' ? 'ERROR' : level === 'warn' ? 'WARNING' : 'INFO';
            console.log(`${prefix}: ${message}`);
          }

          // MCP endpoint with authentication - POST for client-to-server communication
          app.post('/mcp', authenticate, async (req: Request, res: Response) => {
            // In stateless mode, create a new instance of transport and server for each request
            // to ensure complete isolation. A single instance would cause request ID collisions
            // when multiple clients connect concurrently.
            
            const requestId = Math.random().toString(36).substring(2, 15);
            log(`Received POST request to /mcp [ID: ${requestId}]`);
            
            try {
              const server = getServer(); 
              log(`Server instance created successfully [ID: ${requestId}]`);
              
              const transport = new StreamableHTTPServerTransport({
                sessionIdGenerator: undefined,
              });
              log(`Transport created successfully [ID: ${requestId}]`);
              
              res.on('close', () => {
                log(`Request closed [ID: ${requestId}]`);
                transport.close();
                server.close();
              });
              
              await server.connect(transport);
              log(`Server connected to transport [ID: ${requestId}]`);
              
              log(`Handling request [ID: ${requestId}]`);
              await transport.handleRequest(req, res, req.body);
              log(`Request handled successfully [ID: ${requestId}]`);
            } catch (error) {
              log(`Error handling MCP request [ID: ${requestId}]: ${error}`, 'error');
              if (!res.headersSent) {
                res.status(500).json({
                  jsonrpc: '2.0',
                  error: {
                    code: -32603,
                    message: 'Internal server error',
                  },
                  id: null,
                });
              }
            }
          });

          // MCP endpoint with authentication - GET for server-to-client notifications and tool discovery
          app.get('/mcp', authenticate, async (req: Request, res: Response) => {
            const requestId = Math.random().toString(36).substring(2, 15);
            log(`Received GET request to /mcp [ID: ${requestId}]`);
            
            try {
              // Create a server instance
              const server = getServer();
              log(`Server instance created successfully for tool discovery [ID: ${requestId}]`);
              
              // Respond with a simple success message for modern clients
              // This is a simplified response since we don't have access to getMetadata, getTools, etc.
              res.status(200).json({
                jsonrpc: "2.0",
                result: {
                  server: {
                    name: "lightrag-mcp-server",
                    version: "0.1.0"
                  }
                },
                id: null
              });
              
              log(`Tool discovery response sent successfully [ID: ${requestId}]`);
              
              // Clean up
              server.close();
              
            } catch (error) {
              log(`Error handling GET request [ID: ${requestId}]: ${error}`, 'error');
              if (!res.headersSent) {
                res.status(500).json({
                  jsonrpc: '2.0',
                  error: {
                    code: -32603,
                    message: 'Internal server error',
                  },
                  id: null,
                });
              }
            }
          });

          // MCP endpoint with authentication - DELETE for session termination
          app.delete('/mcp', authenticate, async (req: Request, res: Response) => {
            const requestId = Math.random().toString(36).substring(2, 15);
            log(`Received DELETE request to /mcp [ID: ${requestId}]`);
            log(`DELETE method not allowed in stateless mode [ID: ${requestId}]`, 'warn');
            
            res.writeHead(405).end(JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32000,
                message: "Method not allowed in stateless mode."
              },
              id: null
            }));
          });

          // Legacy SSE endpoint for older clients
          app.get('/sse', authenticate, async (req: Request, res: Response) => {
            const requestId = Math.random().toString(36).substring(2, 15);
            log(`Received GET request to /sse [ID: ${requestId}]`);
            
            try {
              const server = getServer();
              log(`Server instance created successfully for SSE [ID: ${requestId}]`);
              
              // Create SSE transport for legacy clients
              const transport = new SSEServerTransport('/messages', res);
              transports.sse[transport.sessionId] = transport;
              
              res.on("close", () => {
                log(`SSE connection closed [ID: ${requestId}]`);
                delete transports.sse[transport.sessionId];
                server.close();
              });
              
              await server.connect(transport);
              log(`Server connected to SSE transport [ID: ${requestId}]`);
            } catch (error) {
              log(`Error handling SSE request [ID: ${requestId}]: ${error}`, 'error');
              if (!res.headersSent) {
                res.status(500).send('Internal server error');
              }
            }
          });

          // Legacy message endpoint for older clients
          app.post('/messages', authenticate, async (req: Request, res: Response) => {
            const sessionId = req.query.sessionId as string;
            const requestId = Math.random().toString(36).substring(2, 15);
            log(`Received POST request to /messages with sessionId ${sessionId} [ID: ${requestId}]`);
            
            const transport = transports.sse[sessionId];
            if (transport) {
              try {
                await transport.handlePostMessage(req, res, req.body);
                log(`Message handled successfully [ID: ${requestId}]`);
              } catch (error) {
                log(`Error handling message [ID: ${requestId}]: ${error}`, 'error');
                if (!res.headersSent) {
                  res.status(500).json({
                    jsonrpc: '2.0',
                    error: {
                      code: -32603,
                      message: 'Internal server error',
                    },
                    id: null,
                  });
                }
              }
            } else {
              log(`No transport found for sessionId ${sessionId} [ID: ${requestId}]`, 'warn');
              res.status(400).json({
                jsonrpc: '2.0',
                error: {
                  code: -32000,
                  message: 'No transport found for sessionId',
                },
                id: null,
              });
            }
          });

          // Start the server
          app.listen(PORT, () => {
            log(`LightRAG MCP Server started successfully`);
            log(`Server is listening on port ${PORT}`);
            log(`Health check endpoint available at http://localhost:${PORT}/health`);
            log(`MCP endpoint available at http://localhost:${PORT}/mcp`);
            log(`Legacy SSE endpoint available at http://localhost:${PORT}/sse`);
            log(`Legacy messages endpoint available at http://localhost:${PORT}/messages`);
            log(`Server is ready to accept requests`);
          });

    environment:
      - LIGHTRAG_API_URL=http://lightrag:9621
      - LIGHTRAG_API_KEY=${SERVICE_BASE64_LIGHTRAG}
      - MCP_API_KEY=${SERVICE_BASE64_MCP}
      - PORT=3000
      - SERVICE_FQDN_MCP_3000
    entrypoint: ["npm", "start"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
volumes:
  neo4j-data: null
  neo4j-logs: null
  neo4j-plugins: null
  neo4j-import: null
